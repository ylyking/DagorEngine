.. autogenerated

**********
dagor.http
**********

module 'dagor.http'



*Source file: prog/gameLibs/quirrel/http/sqHttpClient.cpp*

Usage::

  let { requestHttp, httpRequest, httpAbort, httpDownload, HTTP_SUCCESS, HTTP_FAILED, HTTP_ABORTED, HTTP_SHUTDOWN } = require("dagor.http")

or::

  from "dagor.http" import *

.. code-block:: sq

  //'dagor.http' exports:
  {
    function requestHttp({method, url, userAgent, headers, data, json, callback, context, respEventId, timeout_ms, waitable, needResponseHeaders = "default)"}): table -> integer
    function httpRequest(arg0): table -> _undocumented_
    function httpAbort(arg0): integer -> _undocumented_
    function httpDownload(request_id): integer -> _undocumented_
    value HTTP_SUCCESS
    value HTTP_FAILED
    value HTTP_ABORTED
    value HTTP_SHUTDOWN
  }
  

.. sq:function:: function requestHttp({method, url, userAgent, headers, data, json, callback, context, respEventId, timeout_ms, waitable, needResponseHeaders = "default)"})

  :param method: ("POST" (default), "GET", "HEAD"), optional
  :type method: string

  :param url:  
  :type url: string

  :param userAgent: (optional)
  :type userAgent: string

  :param headers: {string:string} (optional)
  :type headers: table

  :param data: (optional) : request data which is treated as from-urlencoded data. If specified, json field is omitted
  :type data: string|table|class_instance|class

  :param json: (optional) : request data which is treated as json data. If specified, data field is omitted
  :type json: string|table|class_instance|class

  :param callback: ({status, http_code, response, headers}), optional
  :type callback: any_type

  :param context: user data specific for request response, optional
  :type context: table

  :param respEventId: (optional) : event id to send into eventbus
  :type respEventId: string

  :param timeout_ms: (optional), DEF_REQUEST_TIMEOUT_MS by default (10 seconds)
  :type timeout_ms: integer

  :param waitable: (optional, false by default) : if true then this request will be waited for on app shutdown
  :type waitable: bool

  :param needResponseHeaders:  , default = default)
  :type needResponseHeaders: by

  ``Function is kwarged - arguments passed in a table``

  :return: request id
  :rtype: integer





response in eventbus data or in callback will be table


.. code-block:: 
    :caption: response
    

    {
      "status" : integer (SUCCESS, FAILED, ABORTED)
      "http_code" : integer
      "context" : null | table | string
      "headers" : table, optional
      "reponce" : blob, optional
    }



.. sq:function:: function httpRequest(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: table

  ``nparamscheck:2``

  ``typecheck mask: any_type, table``

.. sq:function:: function httpAbort(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: integer

  ``nparamscheck:2``

  ``typecheck mask: any_type, integer``

.. sq:function:: function httpDownload(request_id)

  :param request_id:  
  :type request_id: integer

  ``nparamscheck:2``

  ``typecheck mask: any_type, table``

.. sq:attribute:: HTTP_SUCCESS

.. sq:attribute:: HTTP_FAILED

.. sq:attribute:: HTTP_ABORTED

.. sq:attribute:: HTTP_SHUTDOWN

/;
  module_mgr->addNativeModule("dagor.http", nsTbl);
}

void http_client_wait_active_requests(int timeout_ms)
{
  if (active_requests.empty())
    return;
  int deadLineTime = timeout_ms ? get_time_msec() + timeout_ms : 0;
  do
  {
    auto wit = eastl::find_if(active_requests.begin(), active_requests.end(), [](const auto &req) { return req->waitable; });
    if (wit != active_requests.end() && (!timeout_ms || get_time_msec() <= deadLineTime))
    {
      httprequests::poll();
      sleep_msec(10);
    }
    else
      break;
  } while (1);
}


void http_client_on_vm_shutdown(HSQUIRRELVM vm)
{
  for (auto &req : active_requests)
  {
    if (req->callback.GetVM() == vm || req->context.GetVM() == vm)
    {
      req->callback.Release();
      req->context.Release();
    }
  }
  whitelists.erase(vm);
}


void http_set_domains_whitelist(HSQUIRRELVM vm, const eastl::vector<eastl::string> &domains)
{
  eastl::hash_set<eastl::string> &wl = whitelists[vm];
  wl.clear();
  wl.insert(domains.begin(), domains.end());
}


void http_set_blocking_wait_mode(bool on) { blocking_wait_mode = on; }

} // namespace bindquirrel


