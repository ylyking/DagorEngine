.. autogenerated

**********
dagor.math
**********

module 'dagor.math'



*Source file: prog/gameLibs/quirrel/bindQuirrelEx/sqratDagorMath.cpp*

Usage::

  let { Point2, Point3, Point4, Quat, IPoint3, E3DCOLOR, Color4, matrix_to_euler, euler_to_quat, dir_to_quat, quat_to_euler, quat_to_matrix, quat_rotation_arc, qinterp, cvt, make_tm_quat, make_tm_axis } = require("dagor.math")

or::

  from "dagor.math" import *

.. code-block:: sq

  //'dagor.math' exports:
  {
    class Point2
    class Point3
    class Point4
    class Quat
    class IPoint3
    class E3DCOLOR
    class Color4
    function matrix_to_euler(&tm): TMatrix -> integer
    function euler_to_quat(&e): integer -> inline Quat
    function dir_to_quat(&p): integer -> inline Quat
    function quat_to_euler(&quat): Quat -> integer
    function quat_to_matrix(&quat): Quat -> inline TMatrix
    function quat_rotation_arc()
    function qinterp()
    function cvt()
    function make_tm_quat()
    function make_tm_axis()
  }
  

------------
class Point2
------------

.. sq:method:: Point2(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance or integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  ``typecheck mask: any_type, class_instance or integer_or_float, integer_or_float``

.. sq:attribute:: var Point2.x

.. sq:attribute:: var Point2.y

.. sq:function:: method Point2.lengthSq()

.. sq:function:: method Point2.length()

.. sq:function:: method Point2.normalize()

.. sq:function:: operator Point2._add(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Point2._sub(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Point2._mul(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance or integer_or_float

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance or integer_or_float``

.. sq:function:: operator Point2._unm(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``nparamscheck:1``

  ``typecheck mask: class_instance``

/;

  





------------
class Point3
------------

  Sqrat::Class<Point3> sqPoint3(vm, "Point3");
  sqPoint3 //
    .SquirrelCtor(math_flt_vector_ctor<Point3, 3>, 0, ".x|nnn")
    .Var("x", &Point3::x)
    .Var("y", &Point3::y)
    .Var("z", &Point3::z)
    .Func("lengthSq", &Point3::lengthSq)
    .Func("length", &Point3::length)
    .Func("normalize", &Point3::normalize)
    .SquirrelFunc("_add", op_add<Point3>, 2, "xx")
    .SquirrelFunc("_sub", op_sub<Point3>, 2, "xx")
    .SquirrelFunc("_mul", op_mul<Point3>, 2, "xx|n")
    .SquirrelFunc("_modulo", op_cross<Point3>, 2, "xx")
    .SquirrelFunc("_unm", op_unm<Point3>, 1, "x")
/*

.. sq:method:: Point3(arg0, arg1, arg2)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance or integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: integer_or_float

  ``typecheck mask: any_type, class_instance or integer_or_float, integer_or_float, integer_or_float``

.. sq:attribute:: var Point3.x

.. sq:attribute:: var Point3.y

.. sq:attribute:: var Point3.z

.. sq:function:: method Point3.lengthSq()

.. sq:function:: method Point3.length()

.. sq:function:: method Point3.normalize()

/;

  





------------
class Point4
------------

  Sqrat::Class<Point4> sqPoint4(vm, "Point4");
  sqPoint4 //
    .SquirrelCtor(math_flt_vector_ctor<Point4, 4>, 0, ".x|nnnn")
    .Var("x", &Point4::x)
    .Var("y", &Point4::y)
    .Var("z", &Point4::z)
    .Var("w", &Point4::w)
    .Func("lengthSq", &Point4::lengthSq)
    .Func("length", &Point4::length)
    .SquirrelFunc("_add", op_add<Point4>, 2, "xx")
    .SquirrelFunc("_sub", op_sub<Point4>, 2, "xx")
    .SquirrelFunc("_mul", op_mul<Point4>, 2, "xx|n")
    .SquirrelFunc("_modulo", op_cross<Point4>, 2, "xx")
    .SquirrelFunc("_unm", op_unm<Point4>, 1, "x")
/*

.. sq:method:: Point4(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``typecheck mask: any_type, class_instance``

.. sq:function:: method Point4.orthonormalize()

.. sq:function:: operator Point4._mul(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance or integer_or_float

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance or integer_or_float``

.. sq:function:: operator Point4._add(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Point4._sub(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Point4._modulo(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Point4._set(arg0, arg1, arg2, ...)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: class_instance or integer_or_float

  :param ...: this function accepts unlimited arguments
  :type ...: any_type

  ``nparamscheck:-3``

  ``typecheck mask: class_instance, integer_or_float, class_instance or integer_or_float``

.. sq:function:: method Point4.setcol(arg0, arg1, arg2, ...)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: class_instance or integer_or_float

  :param ...: this function accepts unlimited arguments
  :type ...: any_type

  ``nparamscheck:-3``

  ``typecheck mask: class_instance, integer_or_float, class_instance or integer_or_float``

.. sq:function:: operator Point4._unm(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``nparamscheck:1``

  ``typecheck mask: class_instance``

.. sq:function:: method Point4.inverse()

.. sq:function:: operator Point4._get(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: any_type

  ``nparamscheck:2``

  ``typecheck mask: class_instance``

.. sq:function:: method Point4.getcol(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: any_type

  ``nparamscheck:2``

  ``typecheck mask: class_instance``

/;

  





----------
class Quat
----------

  Sqrat::Class<Quat> sqQuat(vm, "Quat");
  sqQuat //
    .SquirrelCtor(quat_ctor, 0, ".x|nnnn")
    .Var("x", &Quat::x)
    .Var("y", &Quat::y)
    .Var("z", &Quat::z)
    .Var("w", &Quat::w)
    .SquirrelFunc("_mul", op_mul<Quat, Quat>, 2, "xx|n")
    .SquirrelFunc("_mul", op_mul_tm<Quat, Point3>, 2, "xx")
    .SquirrelFunc("_unm", op_unm<Quat>, 1, "x")
    .Func("normalize", &Quat::normalize)
/*

.. sq:method:: Quat(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance or integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  ``typecheck mask: any_type, class_instance or integer_or_float, integer_or_float``

.. sq:attribute:: var Quat.x

.. sq:attribute:: var Quat.y

.. sq:function:: operator Quat._add(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Quat._sub(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator Quat._unm(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``nparamscheck:1``

  ``typecheck mask: class_instance``

/;

  





-------------
class IPoint3
-------------

  Sqrat::Class<IPoint3> sqIPoint3(vm, "IPoint3");
  sqIPoint3 //
    .SquirrelCtor(math_int_vector_ctor<IPoint3, 3>, 0, ".x|nnn")
    .Var("x", &IPoint3::x)
    .Var("y", &IPoint3::y)
    .Var("z", &IPoint3::z)
    .SquirrelFunc("_add", op_add<IPoint3>, 2, "xx")
    .SquirrelFunc("_sub", op_sub<IPoint3>, 2, "xx")
    .SquirrelFunc("_unm", op_unm<IPoint3>, 1, "x")
/*

.. sq:method:: IPoint3(arg0, arg1, arg2, arg3)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance or integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: integer_or_float

  :param arg3: autodoc from typemask/paramscheck
  :type arg3: integer_or_float

  ``typecheck mask: any_type, class_instance or integer_or_float, integer_or_float, integer_or_float, integer_or_float``

.. sq:attribute:: var IPoint3.x

.. sq:attribute:: var IPoint3.y

.. sq:attribute:: var IPoint3.z

.. sq:attribute:: var IPoint3.w

.. sq:function:: operator IPoint3._add(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator IPoint3._sub(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator IPoint3._unm(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``nparamscheck:1``

  ``typecheck mask: class_instance``

/;

  





--------------
class E3DCOLOR
--------------

  Sqrat::Class<E3DCOLOR> sqE3DCOLOR(vm, "E3DCOLOR");
  sqE3DCOLOR //
    .SquirrelCtor(e3dcolor_ctor, 0, ".x|nnnn")
    .Var("r", &E3DCOLOR::r)
    .Var("g", &E3DCOLOR::g)
    .Var("b", &E3DCOLOR::b)
    .Var("a", &E3DCOLOR::a)
    .Var("u", &E3DCOLOR::u)
/*

.. sq:method:: E3DCOLOR(arg0, arg1, arg2, arg3)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance or integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: integer_or_float

  :param arg3: autodoc from typemask/paramscheck
  :type arg3: integer_or_float

  ``typecheck mask: any_type, class_instance or integer_or_float, integer_or_float, integer_or_float, integer_or_float``

.. sq:attribute:: var E3DCOLOR.r

.. sq:attribute:: var E3DCOLOR.g

.. sq:attribute:: var E3DCOLOR.b

.. sq:function:: operator E3DCOLOR._add(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator E3DCOLOR._sub(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance``

.. sq:function:: operator E3DCOLOR._mul(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: class_instance or integer_or_float

  ``nparamscheck:2``

  ``typecheck mask: class_instance, class_instance or integer_or_float``

.. sq:function:: method E3DCOLOR.set(arg0, arg1, arg2)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: integer_or_float

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: integer_or_float

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: integer_or_float

  ``nparamscheck:3``

  ``typecheck mask: integer_or_float, integer_or_float, integer_or_float``

/;

  





------------
class Color4
------------

  Sqrat::Class<Color4> sqColor4(vm, "Color4");
  sqColor4 //
    .SquirrelCtor(color4_ctor, 0, ".x|nnnn")
    .Var("r", &Color4::r)
    .Var("g", &Color4::g)
    .Var("b", &Color4::b)
    .Var("a", &Color4::a)
    .SquirrelFunc("_add", op_add<Color4>, 2, "xx")
    .SquirrelFunc("_sub", op_sub<Color4>, 2, "xx")
    .SquirrelFunc("_mul", op_mul<Color4, Color4>, 2, "xx|n")
    .SquirrelFunc("set", c4_set, 4, "nnnn")
/*




.. sq:function:: function matrix_to_euler(&tm)

  :param &tm:  
  :type &tm: TMatrix

  :return: integer

.. sq:function:: function euler_to_quat(&e)

  :param &e:  
  :type &e: integer

  :return: inline Quat

.. sq:function:: function dir_to_quat(&p)

  :param &p:  
  :type &p: integer

  :return: inline Quat

.. sq:function:: function quat_to_euler(&quat)

  :param &quat:  
  :type &quat: Quat

  :return: integer

.. sq:function:: function quat_to_matrix(&quat)

  :param &quat:  
  :type &quat: Quat

  :return: inline TMatrix

.. sq:function:: function quat_rotation_arc()

.. sq:function:: function qinterp()

.. sq:function:: function cvt()

.. sq:function:: function make_tm_quat()

.. sq:function:: function make_tm_axis()

/;

#define BIND(cn) nsTbl.Bind(#cn, sq##cn);
  BIND(Point2);
  BIND(Point3);
  BIND(Point4);
  BIND(TMatrix);
  BIND(IPoint2);
  BIND(IPoint3);
  BIND(IPoint4);
  BIND(DPoint3);
  BIND(E3DCOLOR);
  BIND(Color3);
  BIND(Color4);
  BIND(Quat);
#undef BIND

  module_mgr->addNativeModule("dagor.math", nsTbl);
}

} // namespace bindquirrel


