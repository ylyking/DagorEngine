.. autogenerated

***
frp
***

module 'frp'



*Source file: prog/gameLibs/quirrel/frp/frp.cpp*

Usage::

  let { Watched, Computed, FRP_INITIAL, FRP_DONT_CHECK_NESTED } = require("frp")

or::

  from "frp" import *

.. code-block:: sq

  //'frp' exports:
  {
    class Watched
    class Computed
    const FRP_INITIAL
    const FRP_DONT_CHECK_NESTED
  }
  

-------------
class Watched
-------------

  Sqrat::DerivedClass<ScriptValueObservable, BaseObservable, Sqrat::NoCopy<ScriptValueObservable>> scriptValueObservable(vm,
    "ScriptValueObservable");
  scriptValueObservable //
    .SquirrelCtor(ScriptValueObservable::script_ctor, -1)
    .Prop("value", &ScriptValueObservable::getValue)
    .Func("get", &ScriptValueObservable::getValue)
    .Prop("timeChangeReq", &ScriptValueObservable::getTimeChangeReq)
    .Prop("timeChanged", &ScriptValueObservable::getTimeChanged)
    .SquirrelFunc("trigger", &ScriptValueObservable::sqTrigger, 1, "x")
    .Func("trace", &ScriptValueObservable::trace)
    .Func("whiteListMutatorClosure", &ScriptValueObservable::whiteListMutatorClosure)
    .SquirrelFunc("update", &ScriptValueObservable::updateViaMethod, 2, "x")
    .SquirrelFunc("set", &ScriptValueObservable::updateViaMethod, 2, "x")
    .SquirrelFunc("modify", &ScriptValueObservable::modify, 2, "xc")
    .SquirrelFunc("_call", &ScriptValueObservable::updateViaCallMm, 3, "x")
    .SquirrelFunc("mutate", &ScriptValueObservable::mutate, 2, "xc")
    .SquirrelFunc("_newslot", &ScriptValueObservable::_newslot, 3, "x")
    .SquirrelFunc("_delslot", &ScriptValueObservable::_delslot, 2, "x")
/*




------------------------------
class Computed extends Watched
------------------------------

.. sq:method:: Computed()

.. sq:function:: method Computed.update()

.. sq:function:: method Computed.mutate()

.. sq:function:: method Computed.set()

.. sq:function:: method Computed.modify()

.. sq:function:: operator Computed._call()

.. sq:function:: operator Computed._newslot()

.. sq:function:: operator Computed._delslot()

.. sq:attribute:: property Computed.used

  ``readonly``

.. sq:function:: method Computed._noComputeErrorFor()

.. sq:function:: method Computed.getSources(arg0)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: class_instance

  ``nparamscheck:1``

  ``typecheck mask: class_instance``

/;

  Sqrat::Table exports(vm);
  exports.Bind("Watched", scriptValueObservable);
  exports.Bind("Computed", sqComputedValue);
  





  exports //
    .SquirrelFunc("set_nested_observable_debug", set_nested_observable_debug, 2, ".b")
    .SquirrelFunc("make_all_observables_immutable", make_all_observables_immutable, 2, ".b")
    .SquirrelFunc("set_default_deferred", set_default_deferred, 2, ".bb")
    .SquirrelFunc("set_recursive_sources", set_recursive_sources, 2, ".b")
    .SquirrelFunc("set_slow_update_threshold_usec", set_slow_update_threshold_usec, 2, ".i")
    .SquirrelFunc("recalc_all_computed_values", recalc_all_computed_values, 1, ".")
    .SquirrelFunc("gather_graph_stats", gather_graph_stats, 1, ".")
    .SquirrelFunc("update_deferred", update_deferred, 1, ".")
    .SquirrelFunc("register_stub_observable_class", ObservablesGraph::register_stub_observable_class, 2, ".y")
/*

.. sq:attribute:: const FRP_INITIAL

.. sq:attribute:: const FRP_DONT_CHECK_NESTED


