.. autogenerated

********
eventbus
********

module 'eventbus'



*Source file: prog/gameLibs/quirrel/sqEventBus/sqEventBus.cpp*

Usage::

  let { eventbus_subscribe, eventbus_subscribe_onehit, eventbus_unsubscribe, eventbus_send, eventbus_send_foreign, eventbus_has_listeners, eventbus_has_foreign_listeners } = require("eventbus")

or::

  from "eventbus" import *

.. code-block:: sq

  //'eventbus' exports:
  {
    function eventbus_subscribe(arg0, arg1, arg2, ...): string, closure_and_nativeclosure, array or string, any_type -> _undocumented_
    function eventbus_subscribe_onehit(arg0, arg1, arg2, ...): string, closure_and_nativeclosure, array or string, any_type -> _undocumented_
    function eventbus_unsubscribe(arg0, arg1): string, closure_and_nativeclosure -> _undocumented_
    function eventbus_send()
    function eventbus_send_foreign()
    function eventbus_has_listeners()
    function eventbus_has_foreign_listeners()
  }
  

.. sq:function:: function eventbus_subscribe(arg0, arg1, arg2, ...)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: string

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: closure_and_nativeclosure

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: array or string

  :param ...: this function accepts unlimited arguments
  :type ...: any_type

  ``nparamscheck:-3``

  ``typecheck mask: any_type, string, closure_and_nativeclosure, array or string``

.. sq:function:: function eventbus_subscribe_onehit(arg0, arg1, arg2, ...)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: string

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: closure_and_nativeclosure

  :param arg2: autodoc from typemask/paramscheck
  :type arg2: array or string

  :param ...: this function accepts unlimited arguments
  :type ...: any_type

  ``nparamscheck:-3``

  ``typecheck mask: any_type, string, closure_and_nativeclosure, array or string``

.. sq:function:: function eventbus_unsubscribe(arg0, arg1)

  :param arg0: autodoc from typemask/paramscheck
  :type arg0: string

  :param arg1: autodoc from typemask/paramscheck
  :type arg1: closure_and_nativeclosure

  ``nparamscheck:3``

  ``typecheck mask: any_type, string, closure_and_nativeclosure``

.. sq:function:: function eventbus_send()

  ``nparamscheck:1``

.. sq:function:: function eventbus_send_foreign()

  ``nparamscheck:1``

.. sq:function:: function eventbus_has_listeners()

  ``nparamscheck:1``

.. sq:function:: function eventbus_has_foreign_listeners()

  ``nparamscheck:1``

/;

  module_mgr->addNativeModule("eventbus", api);
}


void unbind(HSQUIRRELVM vm)
{
  ScopedLockWriteTemplate guard(vmsLock);
  G_ASSERT(!interlocked_acquire_load(is_in_send));
  vms.erase(vm);
}


void clear_on_reload(HSQUIRRELVM vm)
{
  ScopedLockReadTemplate guard(vmsLock);
  G_ASSERT(!interlocked_acquire_load(is_in_send));
  auto itVm = vms.find(vm);
  if (itVm != vms.end())
  {
    ScopedLockWriteTemplate handlerGuard(itVm->second.handlersLock);
    itVm->second.handlers.clear();
  }
}


void do_with_vm(const eastl::function<void(HSQUIRRELVM)> &callback)
{
  ScopedLockReadTemplate guard(vmsLock);
  // return any VM to allow creating script objects that will be passed to all VMs
  auto it = vms.begin();
  callback(it != vms.end() ? it->first : nullptr);
}


void set_native_event_handler(NativeEventHandler handler) { g_native_event_handler = handler; }


} // namespace sqeventbus


